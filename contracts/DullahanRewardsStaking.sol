//██████╗  █████╗ ██╗      █████╗ ██████╗ ██╗███╗   ██╗
//██╔══██╗██╔══██╗██║     ██╔══██╗██╔══██╗██║████╗  ██║
//██████╔╝███████║██║     ███████║██║  ██║██║██╔██╗ ██║
//██╔═══╝ ██╔══██║██║     ██╔══██║██║  ██║██║██║╚██╗██║
//██║     ██║  ██║███████╗██║  ██║██████╔╝██║██║ ╚████║
//╚═╝     ╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝╚═════╝ ╚═╝╚═╝  ╚═══╝


pragma solidity 0.8.16;
//SPDX-License-Identifier: MIT

import "./interfaces/IScalingERC20.sol";
import "./oz/interfaces/IERC20.sol";
import "./oz/interfaces/IERC20.sol";
import "./oz/libraries/SafeERC20.sol";
import "./oz/utils/ReentrancyGuard.sol";
import "./oz/utils/Pausable.sol";
import "./utils/Owner.sol";
import {Errors} from "./utils/Errors.sol";
import {WadRayMath} from  "./utils/WadRayMath.sol";

/** @title DullahanRewardsStaking contract
 *  @author Paladin
 *  @notice Staking system for Dullahan share holders to receive the rewards
 *          generated by Dullahan modules.
 */
contract DullahanRewardsStaking is ReentrancyGuard, Pausable, Owner {
    using SafeERC20 for IERC20;
    using WadRayMath for uint256;


    // Constants

    /** @notice 1e18 scale */
    uint256 private constant UNIT = 1e18;

    uint256 private constant INITIAL_INDEX = 1e27;

    uint256 private constant DISTRIBUTION_DURATION = 604800; // 1 week

    uint256 private constant MAX_BPS = 10000;

    uint256 private constant MAX_UINT256 = 2**256 - 1;

    uint256 private constant UPDATE_REWARD_RATIO = 8500; // 85 %

    uint256 private constant SEED_DEPOSIT = 0.001 ether;


    // Structs

    struct UserRewardState { // to pack better - gas opti
        uint256 lastRewardPerToken;
        uint256 accruedRewards;
    }

    struct RewardState { // to pack better - gas opti
        uint256 rewardPerToken;
        uint256 lastUpdate;
        uint256 ratePerSecond;
        uint256 currentRewardAmount;
        uint256 queuedRewardAmount;
        uint256 distributionEndTimestamp;
        // user address => user reward state
        mapping(address => UserRewardState) userStates;
    }

    /** @notice UserClaimableRewards struct 
    *   reward: address of the reward token
    *   claimableAmount: amount of rewards accrued by the user
    */
    struct UserClaimableRewards {
        address reward;
        uint256 claimableAmount;
    }

    /** @notice UserClaimableRewards struct 
    *   reward: address of the reward token
    *   amount: amount of rewards claimed by the user
    */
    struct UserClaimedRewards {
        address reward;
        uint256 amount;
    }


    // Storage
    bool public initialized;

    address public immutable vault;

    uint256 public totalScaledAmount;
    mapping(address => uint256) public userScaledBalances;

    address[] public rewardList;

    // reward token => reward state
    mapping(address => RewardState) public rewardStates;

    mapping(address => bool) public rewardDepositors;

    /** @notice Address allowed to claim for another user */
    mapping(address => address) public allowedClaimer;


    // Events

    event Initialized();

    event Staked(address indexed caller, address indexed receiver, uint256 amount, uint256 scaledAmount);
    event Unstaked(address indexed owner, address indexed receiver, uint256 amount, uint256 scaledAmount);
    
    /** @notice Event emitted when rewards are claimed */
    event ClaimedRewards(address indexed reward, address indexed user, address indexed receiver, uint256 amount);

    /** @notice Event emitted when a new Claimer is set for an user */
    event SetUserAllowedClaimer(address indexed user, address indexed claimer);

    event NewRewards(address indexed rewardToken, uint256 amount, uint256 endTimestamp);

    /** @notice Event emitted when a new reward depositor is added */
    event AddedRewardDepositor(address indexed depositor);
    /** @notice Event emitted when a reward depositor is removed */
    event RemovedRewardDepositor(address indexed depositor);


    // Modifers

    modifier onlyRewardDepositors() {
        if(!rewardDepositors[msg.sender]) revert Errors.CallerNotAllowed();
        _;
    }

    modifier isInitialized() {
        if (!initialized) revert Errors.NotInitialized();
        _;
    }


    // Constructor

    constructor(
        address _vault
    ) {
        if(_vault == address(0)) revert Errors.AddressZero();

        vault = _vault;
    }

    function init() external onlyOwner {
        if(initialized) revert Errors.AlreadyInitialized();

        initialized = true;

        // Seed deposit to prevent 1 wei LP token exploit
        _stake(msg.sender, SEED_DEPOSIT, msg.sender);

        emit Initialized();
    }


    // View functions

    function lastRewardUpdateTimestamp(address reward) public view returns(uint256) {
        uint256 rewardEndTimestamp = rewardStates[reward].distributionEndTimestamp;
        // If the distribution is already over, return the timestamp of the end of distribution
        // to prevent from accruing rewards that do not exist
        return block.timestamp > rewardEndTimestamp ? rewardEndTimestamp : block.timestamp;
    }

    function totalAssets() public view returns(uint256) {
        return IScalingERC20(vault).balanceOf(address(this));
    }

    function getCurrentIndex() external view returns(uint256) {
        return _getCurrentIndex();
    }

    function getRewardList() public view returns(address[] memory) {
        return rewardList;
    }

    function userCurrentStakedAmount(address user) public view returns(uint256) {
        return userScaledBalances[user].rayMul(_getCurrentIndex());
    }

    function getUserRewardState(address reward, address user) external view returns(UserRewardState memory) {
        return rewardStates[reward].userStates[user];
    }

    function getUserAccruedRewards(address reward, address user) external view returns(uint256) {
        return rewardStates[reward].userStates[user].accruedRewards + _getUserEarnedRewards(reward, user);
    }

    function getUserTotalClaimableRewards(address user) external view returns(UserClaimableRewards[] memory){
        address[] memory rewards = rewardList;
        uint256 rewardsLength = rewards.length;
        UserClaimableRewards[] memory rewardAmounts = new UserClaimableRewards[](rewardsLength);

        // For each listed reward
        for(uint256 i; i < rewardsLength;){
            // Add the reward token to the list
            rewardAmounts[i].reward = rewards[i];
            // And add the calculated claimable amount of the given reward
            rewardAmounts[i].claimableAmount = rewardStates[rewards[i]].userStates[user].accruedRewards + _getUserEarnedRewards(rewards[i], user);

            unchecked { ++i; }
        }
        return rewardAmounts;
    }



    // State-changing functions

    // Can give MAX_UINT256 to stake full balance
    function stake(uint256 amount, address receiver) external nonReentrant isInitialized whenNotPaused returns(uint256) {
        if(amount == 0) revert Errors.NullAmount();
        if(receiver == address(0)) revert Errors.AddressZero();

        return _stake(msg.sender, amount, receiver);
    }

    function _stake(address caller, uint256 amount, address receiver) internal returns(uint256) {
        // We just want to update the reward states for the user who's balance gonna change
        _updateAllUserRewardStates(receiver);

        // If given MAX_UINT256, we want to deposit the full user balance
        if(amount == MAX_UINT256) amount = IERC20(vault).balanceOf(caller);

        // Calculate the scaled amount corresponding to the user deposit
        // based on the total tokens held by this contract (because of the Scaling ERC20 logic)
        uint256 scaledAmount = amount.rayDiv(_getCurrentIndex());
        if(scaledAmount == 0) revert Errors.NullScaledAmount();

        // Pull the tokens from the user
        IERC20(vault).safeTransferFrom(caller, address(this), amount);

        // Update storage
        userScaledBalances[receiver] += scaledAmount;
        totalScaledAmount += scaledAmount;

        emit Staked(caller, receiver, amount, scaledAmount);

        return scaledAmount;
    }

    // Can give MAX_UINT256 to unstake full balance
    function unstake(uint256 scaledAmount, address receiver) external nonReentrant isInitialized returns(uint256) {
        if(scaledAmount == 0) revert Errors.NullScaledAmount();
        if(receiver == address(0)) revert Errors.AddressZero();

        // We just want to update the reward states for the user who's balance gonna change
        _updateAllUserRewardStates(msg.sender);

        // If given MAX_UINT256, we want to withdraw the full user balance
        if(scaledAmount == MAX_UINT256) scaledAmount = userScaledBalances[msg.sender];

        // Calculate the amount to receive based on the given scaled amount
        uint256 amount = scaledAmount.rayMul(_getCurrentIndex());
        if(amount == 0) revert Errors.NullAmount();

        // Update storage
        userScaledBalances[msg.sender] -= scaledAmount;
        totalScaledAmount -= scaledAmount;

        // And send the tokens to the given receiver
        IERC20(vault).safeTransfer(receiver, amount);

        emit Unstaked(msg.sender, receiver, amount, scaledAmount);

        return amount;
    }

    function claimRewards(address reward, address receiver) external nonReentrant isInitialized whenNotPaused returns(uint256) {
        if(receiver == address(0)) revert Errors.AddressZero();

        return _claimRewards(reward, msg.sender, receiver);
    }

    function claimRewardsForUser(address reward, address user, address receiver) external nonReentrant isInitialized whenNotPaused returns(uint256) {
        if(receiver == address(0) || user == address(0)) revert Errors.AddressZero();
        if(msg.sender != allowedClaimer[user]) revert Errors.ClaimNotAllowed();

        return _claimRewards(reward, user, receiver);
    }

    function claimAllRewards(address receiver) external nonReentrant isInitialized whenNotPaused returns(UserClaimedRewards[] memory) {
        if(receiver == address(0)) revert Errors.AddressZero();

        return _claimAllRewards(msg.sender, receiver);
    }

    function claimAllRewardsForUser(address user, address receiver) external nonReentrant isInitialized whenNotPaused returns(UserClaimedRewards[] memory) {
        if(receiver == address(0) || user == address(0)) revert Errors.AddressZero();
        if(msg.sender != allowedClaimer[user]) revert Errors.ClaimNotAllowed();

        return _claimAllRewards(user, receiver);
    }

    function updateRewardState(address reward) external isInitialized whenNotPaused {
        if(reward == address(0)) revert Errors.AddressZero();
        _updateRewardState(reward);
    }

    function updateAllRewardState() external isInitialized whenNotPaused {
        _updateAllRewardStates();
    }


    // Reward Managers functions

    function queueRewards(address rewardToken, uint256 amount) 
        external
        nonReentrant
        isInitialized
        whenNotPaused
        onlyRewardDepositors
        returns(bool) 
    {
        if(amount == 0) revert Errors.NullAmount();
        if(rewardToken == address(0)) revert Errors.AddressZero();

        RewardState storage state = rewardStates[rewardToken];

        // If the given reward token is new (no previous distribution),
        // add it to the reward list
        if(state.lastUpdate == 0) {
            rewardList.push(rewardToken);
        }

        // Update the reward token state before queueing new rewards
        _updateRewardState(rewardToken);

        // Get the total queued amount (previous queued amount + new amount)
        uint256 totalQueued = amount + state.queuedRewardAmount;

        // If there is no current disitrbution (previous is over or new reward token):
        // Start the new distribution directly without queueing the rewards
        if(block.timestamp >= state.distributionEndTimestamp){
            _updateRewardDistribution(rewardToken, state, totalQueued);
            state.queuedRewardAmount = 0;

            return true;
        }

        // Calculate the reamining duration for the current distribution
        // and the ratio of queued rewards compared to total rewards (queued + reamining in current distribution)
        // state.distributionEndTimestamp - block.timestamp => remaining time in the current distribution
        uint256 currentRemainingAmount =  state.ratePerSecond * (state.distributionEndTimestamp - block.timestamp);
        uint256 queuedAmountRatio =  (totalQueued * MAX_BPS) / (totalQueued + currentRemainingAmount);

        // If 85% or more of the total rewards are queued, move them to distribution
        if(queuedAmountRatio >= UPDATE_REWARD_RATIO) {
            _updateRewardDistribution(rewardToken, state, totalQueued);
            state.queuedRewardAmount = 0;
        } else {
            state.queuedRewardAmount = totalQueued;
        }

        return true;
    }

    function _updateRewardDistribution(address rewardToken, RewardState storage state, uint256 rewardAmount) internal {
        // Calculate the remaining duration of the current distribution (if not already over)
        // to calculate the amount fo rewards not yet distributed, and add them to the new amount to distribute
        if(block.timestamp < state.distributionEndTimestamp) {
            uint256 remainingRewards = state.ratePerSecond * (state.distributionEndTimestamp - block.timestamp);
            rewardAmount += remainingRewards;
        }
        // Calculate the new rate per second
        // & update the storage for the new distribution state
        state.ratePerSecond = rewardAmount / DISTRIBUTION_DURATION;
        state.currentRewardAmount = rewardAmount;
        state.lastUpdate = block.timestamp;
        uint256 distributionEnd = block.timestamp + DISTRIBUTION_DURATION;
        state.distributionEndTimestamp = distributionEnd;

        emit NewRewards(rewardToken, rewardAmount, distributionEnd);
    }


    // Internal functions

    function _getCurrentIndex() internal view returns(uint256) {
        if(totalScaledAmount == 0) return INITIAL_INDEX;
        return totalAssets().rayDiv(totalScaledAmount);
    }

    function _getNewRewardPerToken(address reward) internal view returns(uint256) {
        RewardState storage state = rewardStates[reward];

        // If no fudns are deposited, we don't want to distribute rewards
        if(totalScaledAmount == 0) return state.rewardPerToken;

        // Get the last update timestamp
        uint256 lastRewardTimetamp = lastRewardUpdateTimestamp(reward);
        if(state.lastUpdate == lastRewardTimetamp) return state.rewardPerToken;

        // Calculate the increase since the last update
        return state.rewardPerToken + (
            (((lastRewardTimetamp - state.lastUpdate) * state.ratePerSecond) * UNIT) / totalScaledAmount
        );
    }

    function _getUserEarnedRewards(address reward, address user) internal view returns(uint256) {
        UserRewardState storage userState = rewardStates[reward].userStates[user];

        // Get the new rewardPerToken for the reward token, and the user scaled balance
        uint256 currentRewardPerToken = _getNewRewardPerToken(reward);
        uint256 userScaledBalance = userScaledBalances[user];

        if(userScaledBalance == 0) return 0;

        // If the user has a previous deposit (scaled balance is not null), calcualte the
        // earned rewards based on the increase of the rewardPerToken value
        return (userScaledBalance * (currentRewardPerToken - userState.lastRewardPerToken)) / UNIT;
    }

    function _updateRewardState(address reward) internal {
        RewardState storage state = rewardStates[reward];

        // Update the storage with the new reward state 
        state.rewardPerToken = _getNewRewardPerToken(reward);
        state.lastUpdate = lastRewardUpdateTimestamp(reward);
    }

    function _updateUserRewardState(address reward, address user) internal {
        // Update the reward token state before the user's state
        _updateRewardState(reward);

        UserRewardState storage userState = rewardStates[reward].userStates[user];

        // Update the storage with the new reward state 
        userState.accruedRewards += _getUserEarnedRewards(reward, user);
        userState.lastRewardPerToken = rewardStates[reward].rewardPerToken;
    }

    function _updateAllRewardStates() internal {
        address[] memory _rewards = rewardList;
        uint256 length = _rewards.length;

        // For all reward token in the list, update the reward state
        for(uint256 i; i < length;){
            _updateRewardState(_rewards[i]);

            unchecked{ ++i; }
        }
    }

    function _updateAllUserRewardStates(address user) internal {
        address[] memory _rewards = rewardList;
        uint256 length = _rewards.length;

        // For all reward token in the list, update the user's reward state
        for(uint256 i; i < length;){
            _updateUserRewardState(_rewards[i], user);

            unchecked{ ++i; }
        }
    }

    /**
    * @dev Claims rewards of an user for a given reward token and sends them to the receiver address
    * @param reward Address of reward token
    * @param user Address of the user
    * @param receiver Address to receive the rewards
    * @return uint256 : claimed amount
    */
    function _claimRewards(address reward, address user, address receiver) internal returns(uint256) {
        // Update all user states to get all current claimable rewards
        _updateUserRewardState(reward, user);

        UserRewardState storage userState = rewardStates[reward].userStates[user];
        
        // Fetch the amount of rewards accrued by the user
        uint256 rewardAmount = userState.accruedRewards;

        if(rewardAmount == 0) return 0;
        
        // Reset user's accrued rewards
        userState.accruedRewards = 0;

        // If the user accrued rewards, send them to the given receiver
        IERC20(reward).safeTransfer(receiver, rewardAmount);

        emit ClaimedRewards(reward, user, receiver, rewardAmount);

        return rewardAmount;
    }

    /**
    * @dev Claims all rewards of an user and sends them to the receiver address
    * @param user Address of the user
    * @param receiver Address to receive the rewards
    * @return UserClaimedRewards[] : list of claimed rewards
    */
    function _claimAllRewards(address user, address receiver) internal returns(UserClaimedRewards[] memory) {
        address[] memory rewards = rewardList;
        uint256 rewardsLength = rewards.length;

        UserClaimedRewards[] memory rewardAmounts = new UserClaimedRewards[](rewardsLength);

        // Update all user states to get all current claimable rewards
        _updateAllUserRewardStates(user);

        // For each reward token in the reward list
        for(uint256 i; i < rewardsLength; ++i){
            UserRewardState storage userState = rewardStates[rewards[i]].userStates[user];
            
            // Fetch the amount of rewards accrued by the user
            uint256 rewardAmount = userState.accruedRewards;

            // If the user accrued no rewards, skip
            if(rewardAmount == 0) continue;

            // Track the claimed amount for the reward token
            rewardAmounts[i].reward = rewards[i];
            rewardAmounts[i].amount = rewardAmount;
            
            // Reset user's accrued rewards
            userState.accruedRewards = 0;
            
            // For each reward token, send the accrued rewards to the given receiver
            IERC20(rewards[i]).safeTransfer(receiver, rewardAmount);

            emit ClaimedRewards(rewards[i], user, receiver, rewardAmounts[i].amount);
        }

        return rewardAmounts;
    }


    // Admin functions
    
    /**
     * @notice Pause the contract
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice Unpause the contract
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    function addRewardDepositor(address depositor) external onlyOwner {
        if(depositor == address(0)) revert Errors.AddressZero();
        if(rewardDepositors[depositor]) revert Errors.AlreadyListedDepositor();

        rewardDepositors[depositor] = true;

        emit AddedRewardDepositor(depositor);
    }

    function removeRewardDepositor(address depositor) external onlyOwner {
        if(depositor == address(0)) revert Errors.AddressZero();
        if(!rewardDepositors[depositor]) revert Errors.NotListedDepositor();

        rewardDepositors[depositor] = false;

        emit RemovedRewardDepositor(depositor);
    }

    /**
    * @notice Sets a given address as allowed to claim rewards for a given user
    * @dev Sets a given address as allowed to claim rewards for a given user
    * @param user Address of the user
    * @param claimer Address of the allowed claimer
    */
    function setUserAllowedClaimer(address user, address claimer) external onlyOwner {
        if(user == address(0) || claimer == address(0)) revert Errors.AddressZero();

        // Set the given address as the claimer for the given user
        allowedClaimer[user] = claimer;

        emit SetUserAllowedClaimer(user, claimer);
    }


    // Maths

    function safe128(uint256 n) internal pure returns (uint128) {
        if(n > type(uint128).max) revert Errors.NumberExceed128Bits();
        return uint128(n);
    }


}